#ifndef _MY_VECTOR_
#define _MY_VECTOR_
#include "stl_debug"
#include "allocator"
#include <cstddef>
using yb::allocator;
template <typename T, typename Alloc = allocator<T> >
class vector { 
public:
	//type define
	typedef T value_type;
	typedef value_type* pointer;
	typedef value_type* iterator;
	typedef const value_type* const_iterator;
	typedef value_type& reference;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef Alloc data_allocator;
	
	//method
	iterator begin() { return start; }
	iterator end() { return finish; }
	const_iterator begin() const { return (const_iterator) start; }
	const_iterator end() const { return (const_iterator) finish; }
	size_type size() const { return finish - start; }
	size_type capacity() const { return end_of_storage - start; }
	bool empty() const { return size() == 0; }
	reference operator[](size_type n) { return *(start + n); }
	void push_back(const value_type& x);
	void pop_back();
	iterator erase(iterator position);
	
	//constructor
	vector() : start(nullptr), finish(nullptr), end_of_storage(nullptr) { }
	vector(size_type n, const T& value) { _fill_initialize(n, value); }
	explicit vector(size_type n) { _fill_initialize(n, T()); }
protected:
	static data_allocator alloc;
	iterator start;
	iterator finish;
	iterator end_of_storage;
	void _insert_aux(iterator position, const T& value);
	void _deallocate() { if (start) alloc.deallocate(start, end_of_storage - start); }
	void _fill_initialize(size_type n, const T& value);
	void insert_aux(iterator, value_type);//todo:
	
};
template <typename T, typename Alloc>
typename vector<T, Alloc>::data_allocator vector<T, Alloc>::alloc;

template <typename T, typename Alloc>
void vector<T, Alloc>::_fill_initialize(size_type n, const T& value) {
	start = _allocate_n_fill(n, value);
	end_of_storage = finish = start + n;
}

template<typename T, typename Alloc>
void vector<T, Alloc>::push_back(const value_type& x) {
	if (finish != end_of_storage) {
		construct(finish, x);
		++finish;
	} else {
		insert_aux(end(), x);
	}
}

template <typename T, typename Alloc>
void vector<T, Alloc>::pop_back() {
	--finish;
	destroy(finish);
}

template <typename T, typename Alloc>
typename vector<T, Alloc>::iterator vector<T, Alloc>::erase(iterator position) {
	if (position + 1 != end()) {
		copy(position + 1, finish, position);
		finish--;
		destroy(finish);
		return position;
	}
}

#endif
